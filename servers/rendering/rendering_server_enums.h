/**************************************************************************/
/*  rendering_server_enums.h                                              */
/**************************************************************************/
/*                         This file is part of:                          */
/*                             GODOT ENGINE                               */
/*                        https://godotengine.org                         */
/**************************************************************************/
/* Copyright (c) 2014-present Godot Engine contributors (see AUTHORS.md). */
/* Copyright (c) 2007-2014 Juan Linietsky, Ariel Manzur.                  */
/*                                                                        */
/* Permission is hereby granted, free of charge, to any person obtaining  */
/* a copy of this software and associated documentation files (the        */
/* "Software"), to deal in the Software without restriction, including    */
/* without limitation the rights to use, copy, modify, merge, publish,    */
/* distribute, sublicense, and/or sell copies of the Software, and to     */
/* permit persons to whom the Software is furnished to do so, subject to  */
/* the following conditions:                                              */
/*                                                                        */
/* The above copyright notice and this permission notice shall be         */
/* included in all copies or substantial portions of the Software.        */
/*                                                                        */
/* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,        */
/* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF     */
/* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. */
/* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY   */
/* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,   */
/* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE      */
/* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                 */
/**************************************************************************/

#pragma once

#include <cstdint>

namespace RenderingServerEnums {

enum {
	NO_INDEX_ARRAY = -1,
	ARRAY_WEIGHTS_SIZE = 4,
	CANVAS_ITEM_Z_MIN = -4096,
	CANVAS_ITEM_Z_MAX = 4096,
	CANVAS_LAYER_MIN = -2147483648,
	CANVAS_LAYER_MAX = 2147483647,
	MAX_GLOW_LEVELS = 7,
	MAX_CURSORS = 8,
	MAX_2D_DIRECTIONAL_LIGHTS = 8,
	MAX_MESH_SURFACES = 256,
};

/* TEXTURE API */

enum TextureType {
	TEXTURE_TYPE_2D,
	TEXTURE_TYPE_LAYERED,
	TEXTURE_TYPE_3D,
};

enum TextureLayeredType {
	TEXTURE_LAYERED_2D_ARRAY,
	TEXTURE_LAYERED_CUBEMAP,
	TEXTURE_LAYERED_CUBEMAP_ARRAY,
};

enum CubeMapLayer {
	CUBEMAP_LAYER_LEFT,
	CUBEMAP_LAYER_RIGHT,
	CUBEMAP_LAYER_BOTTOM,
	CUBEMAP_LAYER_TOP,
	CUBEMAP_LAYER_FRONT,
	CUBEMAP_LAYER_BACK,
};

enum TextureDrawableFormat {
	TEXTURE_DRAWABLE_FORMAT_RGBA8,
	TEXTURE_DRAWABLE_FORMAT_RGBA8_SRGB, // Use this if you want to read the result from both 2D (non-hdr) and 3D.
	TEXTURE_DRAWABLE_FORMAT_RGBAH,
	TEXTURE_DRAWABLE_FORMAT_RGBAF,
};

enum TextureDetectRoughnessChannel {
	TEXTURE_DETECT_ROUGHNESS_R,
	TEXTURE_DETECT_ROUGHNESS_G,
	TEXTURE_DETECT_ROUGHNESS_B,
	TEXTURE_DETECT_ROUGHNESS_A,
	TEXTURE_DETECT_ROUGHNESS_GRAY,
};

/* PIPELINES API */

enum PipelineSource {
	PIPELINE_SOURCE_CANVAS,
	PIPELINE_SOURCE_MESH,
	PIPELINE_SOURCE_SURFACE,
	PIPELINE_SOURCE_DRAW,
	PIPELINE_SOURCE_SPECIALIZATION,
	PIPELINE_SOURCE_MAX,
};

/* SHADER API */

enum ShaderMode {
	SHADER_SPATIAL,
	SHADER_CANVAS_ITEM,
	SHADER_PARTICLES,
	SHADER_SKY,
	SHADER_FOG,
	SHADER_TEXTURE_BLIT,
	SHADER_MAX,
};

enum CullMode {
	CULL_MODE_DISABLED,
	CULL_MODE_FRONT,
	CULL_MODE_BACK,
};

/* COMMON MATERIAL API */

enum {
	MATERIAL_RENDER_PRIORITY_MIN = -128,
	MATERIAL_RENDER_PRIORITY_MAX = 127,
};

/* MESH API */

enum ArrayType {
	ARRAY_VERTEX = 0, // RG32F (2D), RGB32F, RGBA16 (compressed)
	ARRAY_NORMAL = 1, // RG16
	ARRAY_TANGENT = 2, // BA16 (with normal) or A16 (with vertex, when compressed)
	ARRAY_COLOR = 3, // RGBA8
	ARRAY_TEX_UV = 4, // RG32F or RG16
	ARRAY_TEX_UV2 = 5, // RG32F or RG16
	ARRAY_CUSTOM0 = 6, // Depends on ArrayCustomFormat.
	ARRAY_CUSTOM1 = 7,
	ARRAY_CUSTOM2 = 8,
	ARRAY_CUSTOM3 = 9,
	ARRAY_BONES = 10, // RGBA16UI (x2 if 8 weights)
	ARRAY_WEIGHTS = 11, // RGBA16UNORM (x2 if 8 weights)
	ARRAY_INDEX = 12, // 16 or 32 bits depending on length > 0xFFFF.
	ARRAY_MAX = 13,
};

enum {
	ARRAY_CUSTOM_COUNT = ARRAY_BONES - ARRAY_CUSTOM0
};

enum ArrayCustomFormat {
	ARRAY_CUSTOM_RGBA8_UNORM,
	ARRAY_CUSTOM_RGBA8_SNORM,
	ARRAY_CUSTOM_RG_HALF,
	ARRAY_CUSTOM_RGBA_HALF,
	ARRAY_CUSTOM_R_FLOAT,
	ARRAY_CUSTOM_RG_FLOAT,
	ARRAY_CUSTOM_RGB_FLOAT,
	ARRAY_CUSTOM_RGBA_FLOAT,
	ARRAY_CUSTOM_MAX,
};

enum ArrayFormat : uint64_t {
	/* ARRAY FORMAT FLAGS */
	ARRAY_FORMAT_VERTEX = 1 << ARRAY_VERTEX,
	ARRAY_FORMAT_NORMAL = 1 << ARRAY_NORMAL,
	ARRAY_FORMAT_TANGENT = 1 << ARRAY_TANGENT,
	ARRAY_FORMAT_COLOR = 1 << ARRAY_COLOR,
	ARRAY_FORMAT_TEX_UV = 1 << ARRAY_TEX_UV,
	ARRAY_FORMAT_TEX_UV2 = 1 << ARRAY_TEX_UV2,
	ARRAY_FORMAT_CUSTOM0 = 1 << ARRAY_CUSTOM0,
	ARRAY_FORMAT_CUSTOM1 = 1 << ARRAY_CUSTOM1,
	ARRAY_FORMAT_CUSTOM2 = 1 << ARRAY_CUSTOM2,
	ARRAY_FORMAT_CUSTOM3 = 1 << ARRAY_CUSTOM3,
	ARRAY_FORMAT_BONES = 1 << ARRAY_BONES,
	ARRAY_FORMAT_WEIGHTS = 1 << ARRAY_WEIGHTS,
	ARRAY_FORMAT_INDEX = 1 << ARRAY_INDEX,

	ARRAY_FORMAT_BLEND_SHAPE_MASK = ARRAY_FORMAT_VERTEX | ARRAY_FORMAT_NORMAL | ARRAY_FORMAT_TANGENT,

	ARRAY_FORMAT_CUSTOM_BASE = (ARRAY_INDEX + 1),
	ARRAY_FORMAT_CUSTOM_BITS = 3,
	ARRAY_FORMAT_CUSTOM_MASK = 0x7,
	ARRAY_FORMAT_CUSTOM0_SHIFT = (ARRAY_FORMAT_CUSTOM_BASE + 0),
	ARRAY_FORMAT_CUSTOM1_SHIFT = (ARRAY_FORMAT_CUSTOM_BASE + ARRAY_FORMAT_CUSTOM_BITS),
	ARRAY_FORMAT_CUSTOM2_SHIFT = (ARRAY_FORMAT_CUSTOM_BASE + ARRAY_FORMAT_CUSTOM_BITS * 2),
	ARRAY_FORMAT_CUSTOM3_SHIFT = (ARRAY_FORMAT_CUSTOM_BASE + ARRAY_FORMAT_CUSTOM_BITS * 3),

	ARRAY_COMPRESS_FLAGS_BASE = (ARRAY_INDEX + 1 + 12),

	ARRAY_FLAG_USE_2D_VERTICES = 1 << (ARRAY_COMPRESS_FLAGS_BASE + 0),
	ARRAY_FLAG_USE_DYNAMIC_UPDATE = 1 << (ARRAY_COMPRESS_FLAGS_BASE + 1),
	ARRAY_FLAG_USE_8_BONE_WEIGHTS = 1 << (ARRAY_COMPRESS_FLAGS_BASE + 2),

	ARRAY_FLAG_USES_EMPTY_VERTEX_ARRAY = 1 << (ARRAY_COMPRESS_FLAGS_BASE + 3),

	ARRAY_FLAG_COMPRESS_ATTRIBUTES = 1 << (ARRAY_COMPRESS_FLAGS_BASE + 4),
	// We leave enough room for up to 5 more compression flags.

	ARRAY_FLAG_FORMAT_VERSION_BASE = ARRAY_COMPRESS_FLAGS_BASE + 10,
	ARRAY_FLAG_FORMAT_VERSION_SHIFT = ARRAY_FLAG_FORMAT_VERSION_BASE,
	// When changes are made to the mesh format, add a new version and use it for the CURRENT_VERSION.
	ARRAY_FLAG_FORMAT_VERSION_1 = 0,
	ARRAY_FLAG_FORMAT_VERSION_2 = 1ULL << ARRAY_FLAG_FORMAT_VERSION_SHIFT,
	ARRAY_FLAG_FORMAT_CURRENT_VERSION = ARRAY_FLAG_FORMAT_VERSION_2,
	ARRAY_FLAG_FORMAT_VERSION_MASK = 0xFF, // 8 bits version
};

static_assert(sizeof(ArrayFormat) == 8, "ArrayFormat should be 64 bits long.");

enum PrimitiveType {
	PRIMITIVE_POINTS,
	PRIMITIVE_LINES,
	PRIMITIVE_LINE_STRIP,
	PRIMITIVE_TRIANGLES,
	PRIMITIVE_TRIANGLE_STRIP,
	PRIMITIVE_MAX,
};

enum BlendShapeMode {
	BLEND_SHAPE_MODE_NORMALIZED,
	BLEND_SHAPE_MODE_RELATIVE,
};

/* MULTIMESH API */

enum MultimeshTransformFormat {
	MULTIMESH_TRANSFORM_2D,
	MULTIMESH_TRANSFORM_3D,
};

enum MultimeshPhysicsInterpolationQuality {
	MULTIMESH_INTERP_QUALITY_FAST,
	MULTIMESH_INTERP_QUALITY_HIGH,
};

/* LIGHT API */

enum LightType {
	LIGHT_DIRECTIONAL,
	LIGHT_OMNI,
	LIGHT_SPOT,
};

enum LightParam {
	LIGHT_PARAM_ENERGY,
	LIGHT_PARAM_INDIRECT_ENERGY,
	LIGHT_PARAM_VOLUMETRIC_FOG_ENERGY,
	LIGHT_PARAM_SPECULAR,
	LIGHT_PARAM_RANGE,
	LIGHT_PARAM_SIZE,
	LIGHT_PARAM_ATTENUATION,
	LIGHT_PARAM_SPOT_ANGLE,
	LIGHT_PARAM_SPOT_ATTENUATION,
	LIGHT_PARAM_SHADOW_MAX_DISTANCE,
	LIGHT_PARAM_SHADOW_SPLIT_1_OFFSET,
	LIGHT_PARAM_SHADOW_SPLIT_2_OFFSET,
	LIGHT_PARAM_SHADOW_SPLIT_3_OFFSET,
	LIGHT_PARAM_SHADOW_FADE_START,
	LIGHT_PARAM_SHADOW_NORMAL_BIAS,
	LIGHT_PARAM_SHADOW_BIAS,
	LIGHT_PARAM_SHADOW_PANCAKE_SIZE,
	LIGHT_PARAM_SHADOW_OPACITY,
	LIGHT_PARAM_SHADOW_BLUR,
	LIGHT_PARAM_TRANSMITTANCE_BIAS,
	LIGHT_PARAM_INTENSITY,
	LIGHT_PARAM_MAX,
};

enum LightBakeMode {
	LIGHT_BAKE_DISABLED,
	LIGHT_BAKE_STATIC,
	LIGHT_BAKE_DYNAMIC,
};

enum LightOmniShadowMode {
	LIGHT_OMNI_SHADOW_DUAL_PARABOLOID,
	LIGHT_OMNI_SHADOW_CUBE,
};

enum LightDirectionalShadowMode {
	LIGHT_DIRECTIONAL_SHADOW_ORTHOGONAL,
	LIGHT_DIRECTIONAL_SHADOW_PARALLEL_2_SPLITS,
	LIGHT_DIRECTIONAL_SHADOW_PARALLEL_4_SPLITS,
};

enum LightDirectionalSkyMode {
	LIGHT_DIRECTIONAL_SKY_MODE_LIGHT_AND_SKY,
	LIGHT_DIRECTIONAL_SKY_MODE_LIGHT_ONLY,
	LIGHT_DIRECTIONAL_SKY_MODE_SKY_ONLY,
};

enum ShadowQuality {
	SHADOW_QUALITY_HARD,
	SHADOW_QUALITY_SOFT_VERY_LOW,
	SHADOW_QUALITY_SOFT_LOW,
	SHADOW_QUALITY_SOFT_MEDIUM,
	SHADOW_QUALITY_SOFT_HIGH,
	SHADOW_QUALITY_SOFT_ULTRA,
	SHADOW_QUALITY_MAX,
};

enum LightProjectorFilter {
	LIGHT_PROJECTOR_FILTER_NEAREST,
	LIGHT_PROJECTOR_FILTER_LINEAR,
	LIGHT_PROJECTOR_FILTER_NEAREST_MIPMAPS,
	LIGHT_PROJECTOR_FILTER_LINEAR_MIPMAPS,
	LIGHT_PROJECTOR_FILTER_NEAREST_MIPMAPS_ANISOTROPIC,
	LIGHT_PROJECTOR_FILTER_LINEAR_MIPMAPS_ANISOTROPIC,
};

/* REFLECTION PROBE API */

enum ReflectionProbeUpdateMode {
	REFLECTION_PROBE_UPDATE_ONCE,
	REFLECTION_PROBE_UPDATE_ALWAYS,
};

enum ReflectionProbeAmbientMode {
	REFLECTION_PROBE_AMBIENT_DISABLED,
	REFLECTION_PROBE_AMBIENT_ENVIRONMENT,
	REFLECTION_PROBE_AMBIENT_COLOR,
};

/* DECAL API */

enum DecalTexture {
	DECAL_TEXTURE_ALBEDO,
	DECAL_TEXTURE_NORMAL,
	DECAL_TEXTURE_ORM,
	DECAL_TEXTURE_EMISSION,
	DECAL_TEXTURE_MAX,
};

enum DecalFilter {
	DECAL_FILTER_NEAREST,
	DECAL_FILTER_LINEAR,
	DECAL_FILTER_NEAREST_MIPMAPS,
	DECAL_FILTER_LINEAR_MIPMAPS,
	DECAL_FILTER_NEAREST_MIPMAPS_ANISOTROPIC,
	DECAL_FILTER_LINEAR_MIPMAPS_ANISOTROPIC,
};

/* VOXEL GI API */

enum VoxelGIQuality {
	VOXEL_GI_QUALITY_LOW,
	VOXEL_GI_QUALITY_HIGH,
};

/* LIGHTMAP API */

enum ShadowmaskMode {
	SHADOWMASK_MODE_NONE,
	SHADOWMASK_MODE_REPLACE,
	SHADOWMASK_MODE_OVERLAY,
	SHADOWMASK_MODE_ONLY,
};

/* PARTICLES API */

enum ParticlesMode {
	PARTICLES_MODE_2D,
	PARTICLES_MODE_3D,
};

enum ParticlesTransformAlign {
	PARTICLES_TRANSFORM_ALIGN_DISABLED,
	PARTICLES_TRANSFORM_ALIGN_Z_BILLBOARD,
	PARTICLES_TRANSFORM_ALIGN_Y_TO_VELOCITY,
	PARTICLES_TRANSFORM_ALIGN_Z_BILLBOARD_Y_TO_VELOCITY,
};

enum ParticlesEmitFlags {
	PARTICLES_EMIT_FLAG_POSITION = 1,
	PARTICLES_EMIT_FLAG_ROTATION_SCALE = 2,
	PARTICLES_EMIT_FLAG_VELOCITY = 4,
	PARTICLES_EMIT_FLAG_COLOR = 8,
	PARTICLES_EMIT_FLAG_CUSTOM = 16,
};

enum ParticlesDrawOrder {
	PARTICLES_DRAW_ORDER_INDEX,
	PARTICLES_DRAW_ORDER_LIFETIME,
	PARTICLES_DRAW_ORDER_REVERSE_LIFETIME,
	PARTICLES_DRAW_ORDER_VIEW_DEPTH,
};

/* PARTICLES COLLISION API */

enum ParticlesCollisionType {
	PARTICLES_COLLISION_TYPE_SPHERE_ATTRACT,
	PARTICLES_COLLISION_TYPE_BOX_ATTRACT,
	PARTICLES_COLLISION_TYPE_VECTOR_FIELD_ATTRACT,
	PARTICLES_COLLISION_TYPE_SPHERE_COLLIDE,
	PARTICLES_COLLISION_TYPE_BOX_COLLIDE,
	PARTICLES_COLLISION_TYPE_SDF_COLLIDE,
	PARTICLES_COLLISION_TYPE_HEIGHTFIELD_COLLIDE,
};

enum ParticlesCollisionHeightfieldResolution { // Longest axis resolution.
	PARTICLES_COLLISION_HEIGHTFIELD_RESOLUTION_256,
	PARTICLES_COLLISION_HEIGHTFIELD_RESOLUTION_512,
	PARTICLES_COLLISION_HEIGHTFIELD_RESOLUTION_1024,
	PARTICLES_COLLISION_HEIGHTFIELD_RESOLUTION_2048,
	PARTICLES_COLLISION_HEIGHTFIELD_RESOLUTION_4096,
	PARTICLES_COLLISION_HEIGHTFIELD_RESOLUTION_8192,
	PARTICLES_COLLISION_HEIGHTFIELD_RESOLUTION_MAX,
};

/* FOG VOLUME API */

enum FogVolumeShape {
	FOG_VOLUME_SHAPE_ELLIPSOID,
	FOG_VOLUME_SHAPE_CONE,
	FOG_VOLUME_SHAPE_CYLINDER,
	FOG_VOLUME_SHAPE_BOX,
	FOG_VOLUME_SHAPE_WORLD,
	FOG_VOLUME_SHAPE_MAX,
};

/* VIEWPORT API */

enum CanvasItemTextureFilter {
	CANVAS_ITEM_TEXTURE_FILTER_DEFAULT, // Uses canvas item setting for draw command, uses global setting for canvas item.
	CANVAS_ITEM_TEXTURE_FILTER_NEAREST,
	CANVAS_ITEM_TEXTURE_FILTER_LINEAR,
	CANVAS_ITEM_TEXTURE_FILTER_NEAREST_WITH_MIPMAPS,
	CANVAS_ITEM_TEXTURE_FILTER_LINEAR_WITH_MIPMAPS,
	CANVAS_ITEM_TEXTURE_FILTER_NEAREST_WITH_MIPMAPS_ANISOTROPIC,
	CANVAS_ITEM_TEXTURE_FILTER_LINEAR_WITH_MIPMAPS_ANISOTROPIC,
	CANVAS_ITEM_TEXTURE_FILTER_MAX,
};

enum CanvasItemTextureRepeat {
	CANVAS_ITEM_TEXTURE_REPEAT_DEFAULT, // Uses canvas item setting for draw command, uses global setting for canvas item.
	CANVAS_ITEM_TEXTURE_REPEAT_DISABLED,
	CANVAS_ITEM_TEXTURE_REPEAT_ENABLED,
	CANVAS_ITEM_TEXTURE_REPEAT_MIRROR,
	CANVAS_ITEM_TEXTURE_REPEAT_MAX,
};

enum ViewportScaling3DMode {
	VIEWPORT_SCALING_3D_MODE_BILINEAR,
	VIEWPORT_SCALING_3D_MODE_FSR,
	VIEWPORT_SCALING_3D_MODE_FSR2,
	VIEWPORT_SCALING_3D_MODE_METALFX_SPATIAL,
	VIEWPORT_SCALING_3D_MODE_METALFX_TEMPORAL,
	VIEWPORT_SCALING_3D_MODE_MAX,
	VIEWPORT_SCALING_3D_MODE_OFF = 255, // for internal use only
};

enum ViewportAnisotropicFiltering {
	VIEWPORT_ANISOTROPY_DISABLED,
	VIEWPORT_ANISOTROPY_2X,
	VIEWPORT_ANISOTROPY_4X,
	VIEWPORT_ANISOTROPY_8X,
	VIEWPORT_ANISOTROPY_16X,
	VIEWPORT_ANISOTROPY_MAX,
};

enum ViewportScaling3DType {
	VIEWPORT_SCALING_3D_TYPE_NONE,
	VIEWPORT_SCALING_3D_TYPE_TEMPORAL,
	VIEWPORT_SCALING_3D_TYPE_SPATIAL,
	VIEWPORT_SCALING_3D_TYPE_MAX,
};

enum ViewportUpdateMode {
	VIEWPORT_UPDATE_DISABLED,
	VIEWPORT_UPDATE_ONCE, // Then goes to disabled, must be manually updated.
	VIEWPORT_UPDATE_WHEN_VISIBLE, // Default
	VIEWPORT_UPDATE_WHEN_PARENT_VISIBLE,
	VIEWPORT_UPDATE_ALWAYS,
};

enum ViewportClearMode {
	VIEWPORT_CLEAR_ALWAYS,
	VIEWPORT_CLEAR_NEVER,
	VIEWPORT_CLEAR_ONLY_NEXT_FRAME,
};

enum ViewportEnvironmentMode {
	VIEWPORT_ENVIRONMENT_DISABLED,
	VIEWPORT_ENVIRONMENT_ENABLED,
	VIEWPORT_ENVIRONMENT_INHERIT,
	VIEWPORT_ENVIRONMENT_MAX,
};

enum ViewportSDFOversize {
	VIEWPORT_SDF_OVERSIZE_100_PERCENT,
	VIEWPORT_SDF_OVERSIZE_120_PERCENT,
	VIEWPORT_SDF_OVERSIZE_150_PERCENT,
	VIEWPORT_SDF_OVERSIZE_200_PERCENT,
	VIEWPORT_SDF_OVERSIZE_MAX,
};

enum ViewportSDFScale {
	VIEWPORT_SDF_SCALE_100_PERCENT,
	VIEWPORT_SDF_SCALE_50_PERCENT,
	VIEWPORT_SDF_SCALE_25_PERCENT,
	VIEWPORT_SDF_SCALE_MAX,
};

enum ViewportMSAA {
	VIEWPORT_MSAA_DISABLED,
	VIEWPORT_MSAA_2X,
	VIEWPORT_MSAA_4X,
	VIEWPORT_MSAA_8X,
	VIEWPORT_MSAA_MAX,
};

enum ViewportScreenSpaceAA {
	VIEWPORT_SCREEN_SPACE_AA_DISABLED,
	VIEWPORT_SCREEN_SPACE_AA_FXAA,
	VIEWPORT_SCREEN_SPACE_AA_SMAA,
	VIEWPORT_SCREEN_SPACE_AA_MAX,
};

enum ViewportOcclusionCullingBuildQuality {
	VIEWPORT_OCCLUSION_BUILD_QUALITY_LOW = 0,
	VIEWPORT_OCCLUSION_BUILD_QUALITY_MEDIUM = 1,
	VIEWPORT_OCCLUSION_BUILD_QUALITY_HIGH = 2,
};

enum ViewportRenderInfo {
	VIEWPORT_RENDER_INFO_OBJECTS_IN_FRAME,
	VIEWPORT_RENDER_INFO_PRIMITIVES_IN_FRAME,
	VIEWPORT_RENDER_INFO_DRAW_CALLS_IN_FRAME,
	VIEWPORT_RENDER_INFO_MAX,
};

enum ViewportRenderInfoType {
	VIEWPORT_RENDER_INFO_TYPE_VISIBLE,
	VIEWPORT_RENDER_INFO_TYPE_SHADOW,
	VIEWPORT_RENDER_INFO_TYPE_CANVAS,
	VIEWPORT_RENDER_INFO_TYPE_MAX,
};

enum ViewportDebugDraw {
	VIEWPORT_DEBUG_DRAW_DISABLED,
	VIEWPORT_DEBUG_DRAW_UNSHADED,
	VIEWPORT_DEBUG_DRAW_LIGHTING,
	VIEWPORT_DEBUG_DRAW_OVERDRAW,
	VIEWPORT_DEBUG_DRAW_WIREFRAME,
	VIEWPORT_DEBUG_DRAW_NORMAL_BUFFER,
	VIEWPORT_DEBUG_DRAW_VOXEL_GI_ALBEDO,
	VIEWPORT_DEBUG_DRAW_VOXEL_GI_LIGHTING,
	VIEWPORT_DEBUG_DRAW_VOXEL_GI_EMISSION,
	VIEWPORT_DEBUG_DRAW_SHADOW_ATLAS,
	VIEWPORT_DEBUG_DRAW_DIRECTIONAL_SHADOW_ATLAS,
	VIEWPORT_DEBUG_DRAW_SCENE_LUMINANCE,
	VIEWPORT_DEBUG_DRAW_SSAO,
	VIEWPORT_DEBUG_DRAW_SSIL,
	VIEWPORT_DEBUG_DRAW_PSSM_SPLITS,
	VIEWPORT_DEBUG_DRAW_DECAL_ATLAS,
	VIEWPORT_DEBUG_DRAW_SDFGI,
	VIEWPORT_DEBUG_DRAW_SDFGI_PROBES,
	VIEWPORT_DEBUG_DRAW_GI_BUFFER,
	VIEWPORT_DEBUG_DRAW_DISABLE_LOD,
	VIEWPORT_DEBUG_DRAW_CLUSTER_OMNI_LIGHTS,
	VIEWPORT_DEBUG_DRAW_CLUSTER_SPOT_LIGHTS,
	VIEWPORT_DEBUG_DRAW_CLUSTER_DECALS,
	VIEWPORT_DEBUG_DRAW_CLUSTER_REFLECTION_PROBES,
	VIEWPORT_DEBUG_DRAW_OCCLUDERS,
	VIEWPORT_DEBUG_DRAW_MOTION_VECTORS,
	VIEWPORT_DEBUG_DRAW_INTERNAL_BUFFER,
};

enum ViewportVRSMode {
	VIEWPORT_VRS_DISABLED,
	VIEWPORT_VRS_TEXTURE,
	VIEWPORT_VRS_XR,
	VIEWPORT_VRS_MAX,
};

enum ViewportVRSUpdateMode {
	VIEWPORT_VRS_UPDATE_DISABLED,
	VIEWPORT_VRS_UPDATE_ONCE,
	VIEWPORT_VRS_UPDATE_ALWAYS,
	VIEWPORT_VRS_UPDATE_MAX,
};

/* SKY API */

enum SkyMode {
	SKY_MODE_AUTOMATIC,
	SKY_MODE_QUALITY,
	SKY_MODE_INCREMENTAL,
	SKY_MODE_REALTIME,
};

/* COMPOSITOR EFFECTS API */

enum CompositorEffectFlags {
	COMPOSITOR_EFFECT_FLAG_ACCESS_RESOLVED_COLOR = 1,
	COMPOSITOR_EFFECT_FLAG_ACCESS_RESOLVED_DEPTH = 2,
	COMPOSITOR_EFFECT_FLAG_NEEDS_MOTION_VECTORS = 4,
	COMPOSITOR_EFFECT_FLAG_NEEDS_ROUGHNESS = 8,
	COMPOSITOR_EFFECT_FLAG_NEEDS_SEPARATE_SPECULAR = 16,
};

enum CompositorEffectCallbackType {
	COMPOSITOR_EFFECT_CALLBACK_TYPE_PRE_OPAQUE,
	COMPOSITOR_EFFECT_CALLBACK_TYPE_POST_OPAQUE,
	COMPOSITOR_EFFECT_CALLBACK_TYPE_POST_SKY,
	COMPOSITOR_EFFECT_CALLBACK_TYPE_PRE_TRANSPARENT,
	COMPOSITOR_EFFECT_CALLBACK_TYPE_POST_TRANSPARENT,
	COMPOSITOR_EFFECT_CALLBACK_TYPE_MAX,
	COMPOSITOR_EFFECT_CALLBACK_TYPE_ANY = -1,
};

/* ENVIRONMENT API */

enum EnvironmentBG {
	ENV_BG_CLEAR_COLOR,
	ENV_BG_COLOR,
	ENV_BG_SKY,
	ENV_BG_CANVAS,
	ENV_BG_KEEP,
	ENV_BG_CAMERA_FEED,
	ENV_BG_MAX,
};

enum EnvironmentAmbientSource {
	ENV_AMBIENT_SOURCE_BG,
	ENV_AMBIENT_SOURCE_DISABLED,
	ENV_AMBIENT_SOURCE_COLOR,
	ENV_AMBIENT_SOURCE_SKY,
};

enum EnvironmentReflectionSource {
	ENV_REFLECTION_SOURCE_BG,
	ENV_REFLECTION_SOURCE_DISABLED,
	ENV_REFLECTION_SOURCE_SKY,
};

enum EnvironmentGlowBlendMode {
	ENV_GLOW_BLEND_MODE_ADDITIVE,
	ENV_GLOW_BLEND_MODE_SCREEN,
	ENV_GLOW_BLEND_MODE_SOFTLIGHT,
	ENV_GLOW_BLEND_MODE_REPLACE,
	ENV_GLOW_BLEND_MODE_MIX,
};

enum EnvironmentToneMapper {
	ENV_TONE_MAPPER_LINEAR,
	ENV_TONE_MAPPER_REINHARD,
	ENV_TONE_MAPPER_FILMIC,
	ENV_TONE_MAPPER_ACES,
	ENV_TONE_MAPPER_AGX,
};

enum EnvironmentSSRRoughnessQuality {
	ENV_SSR_ROUGHNESS_QUALITY_DISABLED,
	ENV_SSR_ROUGHNESS_QUALITY_LOW,
	ENV_SSR_ROUGHNESS_QUALITY_MEDIUM,
	ENV_SSR_ROUGHNESS_QUALITY_HIGH,
};

enum EnvironmentSSAOQuality {
	ENV_SSAO_QUALITY_VERY_LOW,
	ENV_SSAO_QUALITY_LOW,
	ENV_SSAO_QUALITY_MEDIUM,
	ENV_SSAO_QUALITY_HIGH,
	ENV_SSAO_QUALITY_ULTRA,
};

enum EnvironmentSSILQuality {
	ENV_SSIL_QUALITY_VERY_LOW,
	ENV_SSIL_QUALITY_LOW,
	ENV_SSIL_QUALITY_MEDIUM,
	ENV_SSIL_QUALITY_HIGH,
	ENV_SSIL_QUALITY_ULTRA,
};

enum EnvironmentSDFGIYScale {
	ENV_SDFGI_Y_SCALE_50_PERCENT,
	ENV_SDFGI_Y_SCALE_75_PERCENT,
	ENV_SDFGI_Y_SCALE_100_PERCENT,
};

enum EnvironmentSDFGIRayCount {
	ENV_SDFGI_RAY_COUNT_4,
	ENV_SDFGI_RAY_COUNT_8,
	ENV_SDFGI_RAY_COUNT_16,
	ENV_SDFGI_RAY_COUNT_32,
	ENV_SDFGI_RAY_COUNT_64,
	ENV_SDFGI_RAY_COUNT_96,
	ENV_SDFGI_RAY_COUNT_128,
	ENV_SDFGI_RAY_COUNT_MAX,
};

enum EnvironmentSDFGIFramesToConverge {
	ENV_SDFGI_CONVERGE_IN_5_FRAMES,
	ENV_SDFGI_CONVERGE_IN_10_FRAMES,
	ENV_SDFGI_CONVERGE_IN_15_FRAMES,
	ENV_SDFGI_CONVERGE_IN_20_FRAMES,
	ENV_SDFGI_CONVERGE_IN_25_FRAMES,
	ENV_SDFGI_CONVERGE_IN_30_FRAMES,
	ENV_SDFGI_CONVERGE_MAX
};

enum EnvironmentSDFGIFramesToUpdateLight {
	ENV_SDFGI_UPDATE_LIGHT_IN_1_FRAME,
	ENV_SDFGI_UPDATE_LIGHT_IN_2_FRAMES,
	ENV_SDFGI_UPDATE_LIGHT_IN_4_FRAMES,
	ENV_SDFGI_UPDATE_LIGHT_IN_8_FRAMES,
	ENV_SDFGI_UPDATE_LIGHT_IN_16_FRAMES,
	ENV_SDFGI_UPDATE_LIGHT_MAX,
};

enum EnvironmentFogMode {
	ENV_FOG_MODE_EXPONENTIAL,
	ENV_FOG_MODE_DEPTH,
};

enum SubSurfaceScatteringQuality {
	SUB_SURFACE_SCATTERING_QUALITY_DISABLED,
	SUB_SURFACE_SCATTERING_QUALITY_LOW,
	SUB_SURFACE_SCATTERING_QUALITY_MEDIUM,
	SUB_SURFACE_SCATTERING_QUALITY_HIGH,
};

/* CAMERA ATTRIBUTES API */

enum DOFBlurQuality {
	DOF_BLUR_QUALITY_VERY_LOW,
	DOF_BLUR_QUALITY_LOW,
	DOF_BLUR_QUALITY_MEDIUM,
	DOF_BLUR_QUALITY_HIGH,
};

enum DOFBokehShape {
	DOF_BOKEH_BOX,
	DOF_BOKEH_HEXAGON,
	DOF_BOKEH_CIRCLE,
};

/* INSTANCING API */

enum InstanceType {
	INSTANCE_NONE,
	INSTANCE_MESH,
	INSTANCE_MULTIMESH,
	INSTANCE_PARTICLES,
	INSTANCE_PARTICLES_COLLISION,
	INSTANCE_LIGHT,
	INSTANCE_REFLECTION_PROBE,
	INSTANCE_DECAL,
	INSTANCE_VOXEL_GI,
	INSTANCE_LIGHTMAP,
	INSTANCE_OCCLUDER,
	INSTANCE_VISIBLITY_NOTIFIER, // TODO: Fix typo in "VISIBILITY" (in 5.0).
	INSTANCE_FOG_VOLUME,
	INSTANCE_MAX,

	INSTANCE_GEOMETRY_MASK = (1 << INSTANCE_MESH) | (1 << INSTANCE_MULTIMESH) | (1 << INSTANCE_PARTICLES)
};

enum InstanceFlags {
	INSTANCE_FLAG_USE_BAKED_LIGHT,
	INSTANCE_FLAG_USE_DYNAMIC_GI,
	INSTANCE_FLAG_DRAW_NEXT_FRAME_IF_VISIBLE,
	INSTANCE_FLAG_IGNORE_OCCLUSION_CULLING,
	INSTANCE_FLAG_MAX,
};

enum ShadowCastingSetting {
	SHADOW_CASTING_SETTING_OFF,
	SHADOW_CASTING_SETTING_ON,
	SHADOW_CASTING_SETTING_DOUBLE_SIDED,
	SHADOW_CASTING_SETTING_SHADOWS_ONLY,
};

enum VisibilityRangeFadeMode {
	VISIBILITY_RANGE_FADE_DISABLED,
	VISIBILITY_RANGE_FADE_SELF,
	VISIBILITY_RANGE_FADE_DEPENDENCIES,
};

/* BAKE API */

enum BakeChannels {
	BAKE_CHANNEL_ALBEDO_ALPHA,
	BAKE_CHANNEL_NORMAL,
	BAKE_CHANNEL_ORM,
	BAKE_CHANNEL_EMISSION,
};

/* CANVAS TEXTURE API */

enum CanvasTextureChannel {
	CANVAS_TEXTURE_CHANNEL_DIFFUSE,
	CANVAS_TEXTURE_CHANNEL_NORMAL,
	CANVAS_TEXTURE_CHANNEL_SPECULAR,
};

/* CANVAS ITEM API */

enum NinePatchAxisMode {
	NINE_PATCH_STRETCH,
	NINE_PATCH_TILE,
	NINE_PATCH_TILE_FIT,
};

enum CanvasGroupMode {
	CANVAS_GROUP_MODE_DISABLED,
	CANVAS_GROUP_MODE_CLIP_ONLY,
	CANVAS_GROUP_MODE_CLIP_AND_DRAW,
	CANVAS_GROUP_MODE_TRANSPARENT,
};

/* CANVAS LIGHT API */

enum CanvasLightMode {
	CANVAS_LIGHT_MODE_POINT,
	CANVAS_LIGHT_MODE_DIRECTIONAL,
};

enum CanvasLightBlendMode {
	CANVAS_LIGHT_BLEND_MODE_ADD,
	CANVAS_LIGHT_BLEND_MODE_SUB,
	CANVAS_LIGHT_BLEND_MODE_MIX,
};

enum CanvasLightShadowFilter {
	CANVAS_LIGHT_FILTER_NONE,
	CANVAS_LIGHT_FILTER_PCF5,
	CANVAS_LIGHT_FILTER_PCF13,
	CANVAS_LIGHT_FILTER_MAX,
};

/* CANVAS OCCLUDER POLYGON API */

enum CanvasOccluderPolygonCullMode {
	CANVAS_OCCLUDER_POLYGON_CULL_DISABLED,
	CANVAS_OCCLUDER_POLYGON_CULL_CLOCKWISE,
	CANVAS_OCCLUDER_POLYGON_CULL_COUNTER_CLOCKWISE,
};

/* GLOBAL SHADER PARAMETERS API */

enum GlobalShaderParameterType {
	GLOBAL_VAR_TYPE_BOOL,
	GLOBAL_VAR_TYPE_BVEC2,
	GLOBAL_VAR_TYPE_BVEC3,
	GLOBAL_VAR_TYPE_BVEC4,
	GLOBAL_VAR_TYPE_INT,
	GLOBAL_VAR_TYPE_IVEC2,
	GLOBAL_VAR_TYPE_IVEC3,
	GLOBAL_VAR_TYPE_IVEC4,
	GLOBAL_VAR_TYPE_RECT2I,
	GLOBAL_VAR_TYPE_UINT,
	GLOBAL_VAR_TYPE_UVEC2,
	GLOBAL_VAR_TYPE_UVEC3,
	GLOBAL_VAR_TYPE_UVEC4,
	GLOBAL_VAR_TYPE_FLOAT,
	GLOBAL_VAR_TYPE_VEC2,
	GLOBAL_VAR_TYPE_VEC3,
	GLOBAL_VAR_TYPE_VEC4,
	GLOBAL_VAR_TYPE_COLOR,
	GLOBAL_VAR_TYPE_RECT2,
	GLOBAL_VAR_TYPE_MAT2,
	GLOBAL_VAR_TYPE_MAT3,
	GLOBAL_VAR_TYPE_MAT4,
	GLOBAL_VAR_TYPE_TRANSFORM_2D,
	GLOBAL_VAR_TYPE_TRANSFORM,
	GLOBAL_VAR_TYPE_SAMPLER2D,
	GLOBAL_VAR_TYPE_SAMPLER2DARRAY,
	GLOBAL_VAR_TYPE_SAMPLER3D,
	GLOBAL_VAR_TYPE_SAMPLERCUBE,
	GLOBAL_VAR_TYPE_SAMPLEREXT,
	GLOBAL_VAR_TYPE_MAX,
};

/* STATUS INFORMATION */

enum RenderingInfo {
	RENDERING_INFO_TOTAL_OBJECTS_IN_FRAME,
	RENDERING_INFO_TOTAL_PRIMITIVES_IN_FRAME,
	RENDERING_INFO_TOTAL_DRAW_CALLS_IN_FRAME,
	RENDERING_INFO_TEXTURE_MEM_USED,
	RENDERING_INFO_BUFFER_MEM_USED,
	RENDERING_INFO_VIDEO_MEM_USED,
	RENDERING_INFO_PIPELINE_COMPILATIONS_CANVAS,
	RENDERING_INFO_PIPELINE_COMPILATIONS_MESH,
	RENDERING_INFO_PIPELINE_COMPILATIONS_SURFACE,
	RENDERING_INFO_PIPELINE_COMPILATIONS_DRAW,
	RENDERING_INFO_PIPELINE_COMPILATIONS_SPECIALIZATION,
	RENDERING_INFO_MAX,
};

/* MISC */

enum SplashStretchMode {
	SPLASH_STRETCH_MODE_DISABLED,
	SPLASH_STRETCH_MODE_KEEP,
	SPLASH_STRETCH_MODE_KEEP_WIDTH,
	SPLASH_STRETCH_MODE_KEEP_HEIGHT,
	SPLASH_STRETCH_MODE_COVER,
	SPLASH_STRETCH_MODE_IGNORE,
};

#ifndef DISABLE_DEPRECATED
// Never actually used, should be removed when we can break compatibility.
enum Features {
	FEATURE_SHADERS,
	FEATURE_MULTITHREADED,
};
#endif

} // namespace RenderingServerEnums

// Alias to make it easier to use.
#define RSE RenderingServerEnums
